var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var PointLight = require("awayjs-core/lib/entities/PointLight");
var AbstractMethodError = require("awayjs-core/lib/errors/AbstractMethodError");
var ShadowMapMethodBase = require("awayjs-stagegl/lib/materials/methods/ShadowMapMethodBase");
/**
 * ShadowMethodBase provides an abstract method for simple (non-wrapping) shadow map methods.
 */
var ShadowMethodBase = (function (_super) {
    __extends(ShadowMethodBase, _super);
    /**
     * Creates a new ShadowMethodBase object.
     * @param castingLight The light used to cast shadows.
     */
    function ShadowMethodBase(castingLight) {
        this._pUsePoint = (castingLight instanceof PointLight);
        _super.call(this, castingLight);
    }
    /**
     * @inheritDoc
     */
    ShadowMethodBase.prototype.iInitVO = function (shaderObject, methodVO) {
        methodVO.needsView = true;
        methodVO.needsGlobalVertexPos = true;
        methodVO.needsGlobalFragmentPos = this._pUsePoint;
        methodVO.needsNormals = shaderObject.numLights > 0;
    };
    /**
     * @inheritDoc
     */
    ShadowMethodBase.prototype.iInitConstants = function (shaderObject, methodVO) {
        var fragmentData = shaderObject.fragmentConstantData;
        var vertexData = shaderObject.vertexConstantData;
        var index = methodVO.fragmentConstantsIndex;
        fragmentData[index] = 1.0;
        fragmentData[index + 1] = 1 / 255.0;
        fragmentData[index + 2] = 1 / 65025.0;
        fragmentData[index + 3] = 1 / 16581375.0;
        fragmentData[index + 6] = 0;
        fragmentData[index + 7] = 1;
        if (this._pUsePoint) {
            fragmentData[index + 8] = 0;
            fragmentData[index + 9] = 0;
            fragmentData[index + 10] = 0;
            fragmentData[index + 11] = 1;
        }
        index = methodVO.vertexConstantsIndex;
        if (index != -1) {
            vertexData[index] = .5;
            vertexData[index + 1] = .5;
            vertexData[index + 2] = 0.0;
            vertexData[index + 3] = 1.0;
        }
    };
    Object.defineProperty(ShadowMethodBase.prototype, "_iDepthMapCoordReg", {
        /**
         * Wrappers that override the vertex shader need to set this explicitly
         */
        get: function () {
            return this._pDepthMapCoordReg;
        },
        set: function (value) {
            this._pDepthMapCoordReg = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    ShadowMethodBase.prototype.iCleanCompilationData = function () {
        _super.prototype.iCleanCompilationData.call(this);
        this._pDepthMapCoordReg = null;
    };
    /**
     * @inheritDoc
     */
    ShadowMethodBase.prototype.iGetVertexCode = function (shaderObject, methodVO, regCache, sharedRegisters) {
        return this._pUsePoint ? this._pGetPointVertexCode(methodVO, regCache, sharedRegisters) : this.pGetPlanarVertexCode(methodVO, regCache, sharedRegisters);
    };
    /**
     * Gets the vertex code for shadow mapping with a point light.
     *
     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
     * @param regCache The register cache used during the compilation.
     */
    ShadowMethodBase.prototype._pGetPointVertexCode = function (methodVO, regCache, sharedRegisters) {
        methodVO.vertexConstantsIndex = -1;
        return "";
    };
    /**
     * Gets the vertex code for shadow mapping with a planar shadow map (fe: directional lights).
     *
     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
     * @param regCache The register cache used during the compilation.
     */
    ShadowMethodBase.prototype.pGetPlanarVertexCode = function (methodVO, regCache, sharedRegisters) {
        var code = "";
        var temp = regCache.getFreeVertexVectorTemp();
        var dataReg = regCache.getFreeVertexConstant();
        var depthMapProj = regCache.getFreeVertexConstant();
        regCache.getFreeVertexConstant();
        regCache.getFreeVertexConstant();
        regCache.getFreeVertexConstant();
        this._pDepthMapCoordReg = regCache.getFreeVarying();
        methodVO.vertexConstantsIndex = dataReg.index * 4;
        // todo: can epsilon be applied here instead of fragment shader?
        code += "m44 " + temp + ", " + sharedRegisters.globalPositionVertex + ", " + depthMapProj + "\n" + "div " + temp + ", " + temp + ", " + temp + ".w\n" + "mul " + temp + ".xy, " + temp + ".xy, " + dataReg + ".xy\n" + "add " + this._pDepthMapCoordReg + ", " + temp + ", " + dataReg + ".xxwz\n";
        //"sub " + this._pDepthMapCoordReg + ".z, " + this._pDepthMapCoordReg + ".z, " + this._pDepthMapCoordReg + ".w\n";
        return code;
    };
    /**
     * @inheritDoc
     */
    ShadowMethodBase.prototype.iGetFragmentCode = function (shaderObject, methodVO, targetReg, registerCache, sharedRegisters) {
        var code = this._pUsePoint ? this._pGetPointFragmentCode(methodVO, targetReg, registerCache, sharedRegisters) : this._pGetPlanarFragmentCode(methodVO, targetReg, registerCache, sharedRegisters);
        code += "add " + targetReg + ".w, " + targetReg + ".w, fc" + (methodVO.fragmentConstantsIndex / 4 + 1) + ".y\n" + "sat " + targetReg + ".w, " + targetReg + ".w\n";
        return code;
    };
    /**
     * Gets the fragment code for shadow mapping with a planar shadow map.
     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
     * @param regCache The register cache used during the compilation.
     * @param targetReg The register to contain the shadow coverage
     * @return
     */
    ShadowMethodBase.prototype._pGetPlanarFragmentCode = function (methodVO, targetReg, regCache, sharedRegisters) {
        throw new AbstractMethodError();
        return "";
    };
    /**
     * Gets the fragment code for shadow mapping with a point light.
     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
     * @param regCache The register cache used during the compilation.
     * @param targetReg The register to contain the shadow coverage
     * @return
     */
    ShadowMethodBase.prototype._pGetPointFragmentCode = function (methodVO, targetReg, regCache, sharedRegisters) {
        throw new AbstractMethodError();
        return "";
    };
    /**
     * @inheritDoc
     */
    ShadowMethodBase.prototype.iSetRenderState = function (shaderObject, methodVO, renderable, stage, camera) {
        if (!this._pUsePoint)
            this._pShadowMapper.iDepthProjection.copyRawDataTo(shaderObject.vertexConstantData, methodVO.vertexConstantsIndex + 4, true);
    };
    /**
     * Gets the fragment code for combining this method with a cascaded shadow map method.
     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
     * @param regCache The register cache used during the compilation.
     * @param decodeRegister The register containing the data to decode the shadow map depth value.
     * @param depthTexture The texture containing the shadow map.
     * @param depthProjection The projection of the fragment relative to the light.
     * @param targetRegister The register to contain the shadow coverage
     * @return
     */
    ShadowMethodBase.prototype._iGetCascadeFragmentCode = function (shaderObject, methodVO, decodeRegister, depthTexture, depthProjection, targetRegister, registerCache, sharedRegisters) {
        throw new Error("This shadow method is incompatible with cascade shadows");
    };
    /**
     * @inheritDoc
     */
    ShadowMethodBase.prototype.iActivate = function (shaderObject, methodVO, stage) {
        var fragmentData = shaderObject.fragmentConstantData;
        var index = methodVO.fragmentConstantsIndex;
        if (this._pUsePoint)
            fragmentData[index + 4] = -Math.pow(1 / (this._pCastingLight.fallOff * this._pEpsilon), 2);
        else
            shaderObject.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1 / (this._pShadowMapper.depth * this._pEpsilon);
        fragmentData[index + 5] = 1 - this._pAlpha;
        if (this._pUsePoint) {
            var pos = this._pCastingLight.scenePosition;
            fragmentData[index + 8] = pos.x;
            fragmentData[index + 9] = pos.y;
            fragmentData[index + 10] = pos.z;
            // used to decompress distance
            var f = this._pCastingLight.fallOff;
            fragmentData[index + 11] = 1 / (2 * f * f);
        }
        if (!this._pUsePoint)
            stage.context.activateRenderTexture(methodVO.texturesIndex, this._pCastingLight.shadowMapper.depthMap);
        //else
        //	(<IContextStageGL> stage.context).activateCubeRenderTexture(methodVO.texturesIndex, <CubeTextureBase> this._pCastingLight.shadowMapper.depthMap);
    };
    /**
     * Sets the method state for cascade shadow mapping.
     */
    ShadowMethodBase.prototype.iActivateForCascade = function (shaderObject, methodVO, stage) {
        throw new Error("This shadow method is incompatible with cascade shadows");
    };
    return ShadowMethodBase;
})(ShadowMapMethodBase);
module.exports = ShadowMethodBase;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1hdGVyaWFscy9tZXRob2RzL3NoYWRvd21ldGhvZGJhc2UudHMiXSwibmFtZXMiOlsiU2hhZG93TWV0aG9kQmFzZSIsIlNoYWRvd01ldGhvZEJhc2UuY29uc3RydWN0b3IiLCJTaGFkb3dNZXRob2RCYXNlLmlJbml0Vk8iLCJTaGFkb3dNZXRob2RCYXNlLmlJbml0Q29uc3RhbnRzIiwiU2hhZG93TWV0aG9kQmFzZS5faURlcHRoTWFwQ29vcmRSZWciLCJTaGFkb3dNZXRob2RCYXNlLmlDbGVhbkNvbXBpbGF0aW9uRGF0YSIsIlNoYWRvd01ldGhvZEJhc2UuaUdldFZlcnRleENvZGUiLCJTaGFkb3dNZXRob2RCYXNlLl9wR2V0UG9pbnRWZXJ0ZXhDb2RlIiwiU2hhZG93TWV0aG9kQmFzZS5wR2V0UGxhbmFyVmVydGV4Q29kZSIsIlNoYWRvd01ldGhvZEJhc2UuaUdldEZyYWdtZW50Q29kZSIsIlNoYWRvd01ldGhvZEJhc2UuX3BHZXRQbGFuYXJGcmFnbWVudENvZGUiLCJTaGFkb3dNZXRob2RCYXNlLl9wR2V0UG9pbnRGcmFnbWVudENvZGUiLCJTaGFkb3dNZXRob2RCYXNlLmlTZXRSZW5kZXJTdGF0ZSIsIlNoYWRvd01ldGhvZEJhc2UuX2lHZXRDYXNjYWRlRnJhZ21lbnRDb2RlIiwiU2hhZG93TWV0aG9kQmFzZS5pQWN0aXZhdGUiLCJTaGFkb3dNZXRob2RCYXNlLmlBY3RpdmF0ZUZvckNhc2NhZGUiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUtBLElBQU8sVUFBVSxXQUFlLHFDQUFxQyxDQUFDLENBQUM7QUFDdkUsSUFBTyxtQkFBbUIsV0FBYSw0Q0FBNEMsQ0FBQyxDQUFDO0FBYXJGLElBQU8sbUJBQW1CLFdBQWEsMERBQTBELENBQUMsQ0FBQztBQUVuRyxBQUdBOztHQURHO0lBQ0csZ0JBQWdCO0lBQVNBLFVBQXpCQSxnQkFBZ0JBLFVBQTRCQTtJQUtqREE7OztPQUdHQTtJQUNIQSxTQVRLQSxnQkFBZ0JBLENBU1RBLFlBQXNCQTtRQUVqQ0MsSUFBSUEsQ0FBQ0EsVUFBVUEsR0FBR0EsQ0FBQ0EsWUFBWUEsWUFBWUEsVUFBVUEsQ0FBQ0EsQ0FBQ0E7UUFFdkRBLGtCQUFNQSxZQUFZQSxDQUFDQSxDQUFDQTtJQUNyQkEsQ0FBQ0E7SUFFREQ7O09BRUdBO0lBQ0lBLGtDQUFPQSxHQUFkQSxVQUFlQSxZQUFpQ0EsRUFBRUEsUUFBaUJBO1FBRWxFRSxRQUFRQSxDQUFDQSxTQUFTQSxHQUFHQSxJQUFJQSxDQUFDQTtRQUMxQkEsUUFBUUEsQ0FBQ0Esb0JBQW9CQSxHQUFHQSxJQUFJQSxDQUFDQTtRQUNyQ0EsUUFBUUEsQ0FBQ0Esc0JBQXNCQSxHQUFHQSxJQUFJQSxDQUFDQSxVQUFVQSxDQUFDQTtRQUNsREEsUUFBUUEsQ0FBQ0EsWUFBWUEsR0FBR0EsWUFBWUEsQ0FBQ0EsU0FBU0EsR0FBR0EsQ0FBQ0EsQ0FBQ0E7SUFDcERBLENBQUNBO0lBRURGOztPQUVHQTtJQUNJQSx5Q0FBY0EsR0FBckJBLFVBQXNCQSxZQUE2QkEsRUFBRUEsUUFBaUJBO1FBRXJFRyxJQUFJQSxZQUFZQSxHQUFpQkEsWUFBWUEsQ0FBQ0Esb0JBQW9CQSxDQUFDQTtRQUNuRUEsSUFBSUEsVUFBVUEsR0FBaUJBLFlBQVlBLENBQUNBLGtCQUFrQkEsQ0FBQ0E7UUFDL0RBLElBQUlBLEtBQUtBLEdBQWtCQSxRQUFRQSxDQUFDQSxzQkFBc0JBLENBQUNBO1FBQzNEQSxZQUFZQSxDQUFDQSxLQUFLQSxDQUFDQSxHQUFHQSxHQUFHQSxDQUFDQTtRQUMxQkEsWUFBWUEsQ0FBQ0EsS0FBS0EsR0FBR0EsQ0FBQ0EsQ0FBQ0EsR0FBR0EsQ0FBQ0EsR0FBQ0EsS0FBS0EsQ0FBQ0E7UUFDbENBLFlBQVlBLENBQUNBLEtBQUtBLEdBQUdBLENBQUNBLENBQUNBLEdBQUdBLENBQUNBLEdBQUNBLE9BQU9BLENBQUNBO1FBQ3BDQSxZQUFZQSxDQUFDQSxLQUFLQSxHQUFHQSxDQUFDQSxDQUFDQSxHQUFHQSxDQUFDQSxHQUFDQSxVQUFVQSxDQUFDQTtRQUV2Q0EsWUFBWUEsQ0FBQ0EsS0FBS0EsR0FBR0EsQ0FBQ0EsQ0FBQ0EsR0FBR0EsQ0FBQ0EsQ0FBQ0E7UUFDNUJBLFlBQVlBLENBQUNBLEtBQUtBLEdBQUdBLENBQUNBLENBQUNBLEdBQUdBLENBQUNBLENBQUNBO1FBRTVCQSxFQUFFQSxDQUFDQSxDQUFDQSxJQUFJQSxDQUFDQSxVQUFVQSxDQUFDQSxDQUFDQSxDQUFDQTtZQUNyQkEsWUFBWUEsQ0FBQ0EsS0FBS0EsR0FBR0EsQ0FBQ0EsQ0FBQ0EsR0FBR0EsQ0FBQ0EsQ0FBQ0E7WUFDNUJBLFlBQVlBLENBQUNBLEtBQUtBLEdBQUdBLENBQUNBLENBQUNBLEdBQUdBLENBQUNBLENBQUNBO1lBQzVCQSxZQUFZQSxDQUFDQSxLQUFLQSxHQUFHQSxFQUFFQSxDQUFDQSxHQUFHQSxDQUFDQSxDQUFDQTtZQUM3QkEsWUFBWUEsQ0FBQ0EsS0FBS0EsR0FBR0EsRUFBRUEsQ0FBQ0EsR0FBR0EsQ0FBQ0EsQ0FBQ0E7UUFDOUJBLENBQUNBO1FBRURBLEtBQUtBLEdBQUdBLFFBQVFBLENBQUNBLG9CQUFvQkEsQ0FBQ0E7UUFDdENBLEVBQUVBLENBQUNBLENBQUNBLEtBQUtBLElBQUlBLENBQUNBLENBQUNBLENBQUNBLENBQUNBLENBQUNBO1lBQ2pCQSxVQUFVQSxDQUFDQSxLQUFLQSxDQUFDQSxHQUFHQSxFQUFFQSxDQUFDQTtZQUN2QkEsVUFBVUEsQ0FBQ0EsS0FBS0EsR0FBR0EsQ0FBQ0EsQ0FBQ0EsR0FBR0EsRUFBRUEsQ0FBQ0E7WUFDM0JBLFVBQVVBLENBQUNBLEtBQUtBLEdBQUdBLENBQUNBLENBQUNBLEdBQUdBLEdBQUdBLENBQUNBO1lBQzVCQSxVQUFVQSxDQUFDQSxLQUFLQSxHQUFHQSxDQUFDQSxDQUFDQSxHQUFHQSxHQUFHQSxDQUFDQTtRQUM3QkEsQ0FBQ0E7SUFDRkEsQ0FBQ0E7SUFLREgsc0JBQVdBLGdEQUFrQkE7UUFIN0JBOztXQUVHQTthQUNIQTtZQUVDSSxNQUFNQSxDQUFDQSxJQUFJQSxDQUFDQSxrQkFBa0JBLENBQUNBO1FBQ2hDQSxDQUFDQTthQUVESixVQUE4QkEsS0FBMkJBO1lBRXhESSxJQUFJQSxDQUFDQSxrQkFBa0JBLEdBQUdBLEtBQUtBLENBQUNBO1FBQ2pDQSxDQUFDQTs7O09BTEFKO0lBT0RBOztPQUVHQTtJQUNJQSxnREFBcUJBLEdBQTVCQTtRQUVDSyxnQkFBS0EsQ0FBQ0EscUJBQXFCQSxXQUFFQSxDQUFDQTtRQUU5QkEsSUFBSUEsQ0FBQ0Esa0JBQWtCQSxHQUFHQSxJQUFJQSxDQUFDQTtJQUNoQ0EsQ0FBQ0E7SUFFREw7O09BRUdBO0lBQ0lBLHlDQUFjQSxHQUFyQkEsVUFBc0JBLFlBQTZCQSxFQUFFQSxRQUFpQkEsRUFBRUEsUUFBNEJBLEVBQUVBLGVBQWtDQTtRQUV2SU0sTUFBTUEsQ0FBQ0EsSUFBSUEsQ0FBQ0EsVUFBVUEsR0FBRUEsSUFBSUEsQ0FBQ0Esb0JBQW9CQSxDQUFDQSxRQUFRQSxFQUFFQSxRQUFRQSxFQUFFQSxlQUFlQSxDQUFDQSxHQUFDQSxJQUFJQSxDQUFDQSxvQkFBb0JBLENBQUNBLFFBQVFBLEVBQUVBLFFBQVFBLEVBQUVBLGVBQWVBLENBQUNBLENBQUNBO0lBQ3ZKQSxDQUFDQTtJQUVETjs7Ozs7T0FLR0E7SUFDSUEsK0NBQW9CQSxHQUEzQkEsVUFBNEJBLFFBQWlCQSxFQUFFQSxRQUE0QkEsRUFBRUEsZUFBa0NBO1FBRTlHTyxRQUFRQSxDQUFDQSxvQkFBb0JBLEdBQUdBLENBQUNBLENBQUNBLENBQUNBO1FBQ25DQSxNQUFNQSxDQUFDQSxFQUFFQSxDQUFDQTtJQUNYQSxDQUFDQTtJQUVEUDs7Ozs7T0FLR0E7SUFDSUEsK0NBQW9CQSxHQUEzQkEsVUFBNEJBLFFBQWlCQSxFQUFFQSxRQUE0QkEsRUFBRUEsZUFBa0NBO1FBRTlHUSxJQUFJQSxJQUFJQSxHQUFVQSxFQUFFQSxDQUFDQTtRQUNyQkEsSUFBSUEsSUFBSUEsR0FBeUJBLFFBQVFBLENBQUNBLHVCQUF1QkEsRUFBRUEsQ0FBQ0E7UUFDcEVBLElBQUlBLE9BQU9BLEdBQXlCQSxRQUFRQSxDQUFDQSxxQkFBcUJBLEVBQUVBLENBQUNBO1FBQ3JFQSxJQUFJQSxZQUFZQSxHQUF5QkEsUUFBUUEsQ0FBQ0EscUJBQXFCQSxFQUFFQSxDQUFDQTtRQUMxRUEsUUFBUUEsQ0FBQ0EscUJBQXFCQSxFQUFFQSxDQUFDQTtRQUNqQ0EsUUFBUUEsQ0FBQ0EscUJBQXFCQSxFQUFFQSxDQUFDQTtRQUNqQ0EsUUFBUUEsQ0FBQ0EscUJBQXFCQSxFQUFFQSxDQUFDQTtRQUNqQ0EsSUFBSUEsQ0FBQ0Esa0JBQWtCQSxHQUFHQSxRQUFRQSxDQUFDQSxjQUFjQSxFQUFFQSxDQUFDQTtRQUNwREEsUUFBUUEsQ0FBQ0Esb0JBQW9CQSxHQUFHQSxPQUFPQSxDQUFDQSxLQUFLQSxHQUFDQSxDQUFDQSxDQUFDQTtRQUVoREEsQUFFQUEsZ0VBRmdFQTtRQUVoRUEsSUFBSUEsSUFBSUEsTUFBTUEsR0FBR0EsSUFBSUEsR0FBR0EsSUFBSUEsR0FBR0EsZUFBZUEsQ0FBQ0Esb0JBQW9CQSxHQUFHQSxJQUFJQSxHQUFHQSxZQUFZQSxHQUFHQSxJQUFJQSxHQUFHQSxNQUFNQSxHQUFHQSxJQUFJQSxHQUFHQSxJQUFJQSxHQUFHQSxJQUFJQSxHQUFHQSxJQUFJQSxHQUFHQSxJQUFJQSxHQUFHQSxNQUFNQSxHQUFHQSxNQUFNQSxHQUFHQSxJQUFJQSxHQUFHQSxPQUFPQSxHQUFHQSxJQUFJQSxHQUFHQSxPQUFPQSxHQUFHQSxPQUFPQSxHQUFHQSxPQUFPQSxHQUFHQSxNQUFNQSxHQUFHQSxJQUFJQSxDQUFDQSxrQkFBa0JBLEdBQUdBLElBQUlBLEdBQUdBLElBQUlBLEdBQUdBLElBQUlBLEdBQUdBLE9BQU9BLEdBQUdBLFNBQVNBLENBQUNBO1FBQ25TQSxBQUVBQSxrSEFGa0hBO1FBRWxIQSxNQUFNQSxDQUFDQSxJQUFJQSxDQUFDQTtJQUNiQSxDQUFDQTtJQUVEUjs7T0FFR0E7SUFDSUEsMkNBQWdCQSxHQUF2QkEsVUFBd0JBLFlBQTZCQSxFQUFFQSxRQUFpQkEsRUFBRUEsU0FBK0JBLEVBQUVBLGFBQWlDQSxFQUFFQSxlQUFrQ0E7UUFFL0tTLElBQUlBLElBQUlBLEdBQVVBLElBQUlBLENBQUNBLFVBQVVBLEdBQUVBLElBQUlBLENBQUNBLHNCQUFzQkEsQ0FBQ0EsUUFBUUEsRUFBRUEsU0FBU0EsRUFBRUEsYUFBYUEsRUFBRUEsZUFBZUEsQ0FBQ0EsR0FBQ0EsSUFBSUEsQ0FBQ0EsdUJBQXVCQSxDQUFDQSxRQUFRQSxFQUFFQSxTQUFTQSxFQUFFQSxhQUFhQSxFQUFFQSxlQUFlQSxDQUFDQSxDQUFDQTtRQUN0TUEsSUFBSUEsSUFBSUEsTUFBTUEsR0FBR0EsU0FBU0EsR0FBR0EsTUFBTUEsR0FBR0EsU0FBU0EsR0FBR0EsUUFBUUEsR0FBR0EsQ0FBQ0EsUUFBUUEsQ0FBQ0Esc0JBQXNCQSxHQUFDQSxDQUFDQSxHQUFHQSxDQUFDQSxDQUFDQSxHQUFHQSxNQUFNQSxHQUFHQSxNQUFNQSxHQUFHQSxTQUFTQSxHQUFHQSxNQUFNQSxHQUFHQSxTQUFTQSxHQUFHQSxNQUFNQSxDQUFDQTtRQUNqS0EsTUFBTUEsQ0FBQ0EsSUFBSUEsQ0FBQ0E7SUFDYkEsQ0FBQ0E7SUFFRFQ7Ozs7OztPQU1HQTtJQUNJQSxrREFBdUJBLEdBQTlCQSxVQUErQkEsUUFBaUJBLEVBQUVBLFNBQStCQSxFQUFFQSxRQUE0QkEsRUFBRUEsZUFBa0NBO1FBRWxKVSxNQUFNQSxJQUFJQSxtQkFBbUJBLEVBQUVBLENBQUNBO1FBQ2hDQSxNQUFNQSxDQUFDQSxFQUFFQSxDQUFDQTtJQUNYQSxDQUFDQTtJQUVEVjs7Ozs7O09BTUdBO0lBQ0lBLGlEQUFzQkEsR0FBN0JBLFVBQThCQSxRQUFpQkEsRUFBRUEsU0FBK0JBLEVBQUVBLFFBQTRCQSxFQUFFQSxlQUFrQ0E7UUFFakpXLE1BQU1BLElBQUlBLG1CQUFtQkEsRUFBRUEsQ0FBQ0E7UUFDaENBLE1BQU1BLENBQUNBLEVBQUVBLENBQUNBO0lBQ1hBLENBQUNBO0lBRURYOztPQUVHQTtJQUNJQSwwQ0FBZUEsR0FBdEJBLFVBQXVCQSxZQUE2QkEsRUFBRUEsUUFBaUJBLEVBQUVBLFVBQXlCQSxFQUFFQSxLQUFXQSxFQUFFQSxNQUFhQTtRQUU3SFksRUFBRUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsSUFBSUEsQ0FBQ0EsVUFBVUEsQ0FBQ0E7WUFDT0EsSUFBSUEsQ0FBQ0EsY0FBZUEsQ0FBQ0EsZ0JBQWdCQSxDQUFDQSxhQUFhQSxDQUFDQSxZQUFZQSxDQUFDQSxrQkFBa0JBLEVBQUVBLFFBQVFBLENBQUNBLG9CQUFvQkEsR0FBR0EsQ0FBQ0EsRUFBRUEsSUFBSUEsQ0FBQ0EsQ0FBQ0E7SUFDM0pBLENBQUNBO0lBRURaOzs7Ozs7Ozs7T0FTR0E7SUFDSUEsbURBQXdCQSxHQUEvQkEsVUFBZ0NBLFlBQTZCQSxFQUFFQSxRQUFpQkEsRUFBRUEsY0FBb0NBLEVBQUVBLFlBQWtDQSxFQUFFQSxlQUFxQ0EsRUFBRUEsY0FBb0NBLEVBQUVBLGFBQWlDQSxFQUFFQSxlQUFrQ0E7UUFFN1NhLE1BQU1BLElBQUlBLEtBQUtBLENBQUNBLHlEQUF5REEsQ0FBQ0EsQ0FBQ0E7SUFDNUVBLENBQUNBO0lBRURiOztPQUVHQTtJQUNJQSxvQ0FBU0EsR0FBaEJBLFVBQWlCQSxZQUE2QkEsRUFBRUEsUUFBaUJBLEVBQUVBLEtBQVdBO1FBRTdFYyxJQUFJQSxZQUFZQSxHQUFpQkEsWUFBWUEsQ0FBQ0Esb0JBQW9CQSxDQUFDQTtRQUNuRUEsSUFBSUEsS0FBS0EsR0FBa0JBLFFBQVFBLENBQUNBLHNCQUFzQkEsQ0FBQ0E7UUFFM0RBLEVBQUVBLENBQUNBLENBQUNBLElBQUlBLENBQUNBLFVBQVVBLENBQUNBO1lBQ25CQSxZQUFZQSxDQUFDQSxLQUFLQSxHQUFHQSxDQUFDQSxDQUFDQSxHQUFHQSxDQUFDQSxJQUFJQSxDQUFDQSxHQUFHQSxDQUFDQSxDQUFDQSxHQUFDQSxDQUFlQSxJQUFJQSxDQUFDQSxjQUFlQSxDQUFDQSxPQUFPQSxHQUFDQSxJQUFJQSxDQUFDQSxTQUFTQSxDQUFDQSxFQUFFQSxDQUFDQSxDQUFDQSxDQUFDQTtRQUN2R0EsSUFBSUE7WUFDSEEsWUFBWUEsQ0FBQ0Esa0JBQWtCQSxDQUFDQSxRQUFRQSxDQUFDQSxvQkFBb0JBLEdBQUdBLENBQUNBLENBQUNBLEdBQUdBLENBQUNBLENBQUNBLEdBQUNBLENBQTRCQSxJQUFJQSxDQUFDQSxjQUFlQSxDQUFDQSxLQUFLQSxHQUFDQSxJQUFJQSxDQUFDQSxTQUFTQSxDQUFDQSxDQUFDQTtRQUVoSkEsWUFBWUEsQ0FBQ0EsS0FBS0EsR0FBR0EsQ0FBQ0EsQ0FBQ0EsR0FBR0EsQ0FBQ0EsR0FBR0EsSUFBSUEsQ0FBQ0EsT0FBT0EsQ0FBQ0E7UUFFM0NBLEVBQUVBLENBQUNBLENBQUNBLElBQUlBLENBQUNBLFVBQVVBLENBQUNBLENBQUNBLENBQUNBO1lBQ3JCQSxJQUFJQSxHQUFHQSxHQUFZQSxJQUFJQSxDQUFDQSxjQUFjQSxDQUFDQSxhQUFhQSxDQUFDQTtZQUNyREEsWUFBWUEsQ0FBQ0EsS0FBS0EsR0FBR0EsQ0FBQ0EsQ0FBQ0EsR0FBR0EsR0FBR0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7WUFDaENBLFlBQVlBLENBQUNBLEtBQUtBLEdBQUdBLENBQUNBLENBQUNBLEdBQUdBLEdBQUdBLENBQUNBLENBQUNBLENBQUNBO1lBQ2hDQSxZQUFZQSxDQUFDQSxLQUFLQSxHQUFHQSxFQUFFQSxDQUFDQSxHQUFHQSxHQUFHQSxDQUFDQSxDQUFDQSxDQUFDQTtZQUNqQ0EsQUFDQUEsOEJBRDhCQTtnQkFDMUJBLENBQUNBLEdBQXdCQSxJQUFJQSxDQUFDQSxjQUFlQSxDQUFDQSxPQUFPQSxDQUFDQTtZQUMxREEsWUFBWUEsQ0FBQ0EsS0FBS0EsR0FBR0EsRUFBRUEsQ0FBQ0EsR0FBR0EsQ0FBQ0EsR0FBQ0EsQ0FBQ0EsQ0FBQ0EsR0FBQ0EsQ0FBQ0EsR0FBQ0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDdENBLENBQUNBO1FBRURBLEVBQUVBLENBQUNBLENBQUNBLENBQUNBLElBQUlBLENBQUNBLFVBQVVBLENBQUNBO1lBQ0RBLEtBQUtBLENBQUNBLE9BQVFBLENBQUNBLHFCQUFxQkEsQ0FBQ0EsUUFBUUEsQ0FBQ0EsYUFBYUEsRUFBa0JBLElBQUlBLENBQUNBLGNBQWNBLENBQUNBLFlBQVlBLENBQUNBLFFBQVFBLENBQUNBLENBQUNBO1FBQzVJQSxNQUFNQTtRQUNOQSxvSkFBb0pBO0lBQ3JKQSxDQUFDQTtJQUVEZDs7T0FFR0E7SUFDSUEsOENBQW1CQSxHQUExQkEsVUFBMkJBLFlBQTZCQSxFQUFFQSxRQUFpQkEsRUFBRUEsS0FBV0E7UUFFdkZlLE1BQU1BLElBQUlBLEtBQUtBLENBQUNBLHlEQUF5REEsQ0FBQ0EsQ0FBQ0E7SUFDNUVBLENBQUNBO0lBQ0ZmLHVCQUFDQTtBQUFEQSxDQWxPQSxBQWtPQ0EsRUFsTzhCLG1CQUFtQixFQWtPakQ7QUFFRCxBQUEwQixpQkFBakIsZ0JBQWdCLENBQUMiLCJmaWxlIjoibWF0ZXJpYWxzL21ldGhvZHMvU2hhZG93TWV0aG9kQmFzZS5qcyIsInNvdXJjZVJvb3QiOiIvVXNlcnMvcm9iYmF0ZW1hbi9XZWJzdG9ybVByb2plY3RzL2F3YXlqcy1zdGFnZWdsLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMaWdodEJhc2VcdFx0XHRcdFx0PSByZXF1aXJlKFwiYXdheWpzLWNvcmUvbGliL2NvcmUvYmFzZS9MaWdodEJhc2VcIik7XG5pbXBvcnQgU3RhZ2VcdFx0XHRcdFx0XHQ9IHJlcXVpcmUoXCJhd2F5anMtc3RhZ2VnbC9saWIvY29yZS9iYXNlL1N0YWdlXCIpO1xuaW1wb3J0IFZlY3RvcjNEXHRcdFx0XHRcdFx0PSByZXF1aXJlKFwiYXdheWpzLWNvcmUvbGliL2NvcmUvZ2VvbS9WZWN0b3IzRFwiKTtcbmltcG9ydCBDYW1lcmFcdFx0XHRcdFx0XHQ9IHJlcXVpcmUoXCJhd2F5anMtY29yZS9saWIvZW50aXRpZXMvQ2FtZXJhXCIpO1xuaW1wb3J0IERpcmVjdGlvbmFsTGlnaHRcdFx0XHRcdD0gcmVxdWlyZShcImF3YXlqcy1jb3JlL2xpYi9lbnRpdGllcy9EaXJlY3Rpb25hbExpZ2h0XCIpO1xuaW1wb3J0IFBvaW50TGlnaHRcdFx0XHRcdFx0PSByZXF1aXJlKFwiYXdheWpzLWNvcmUvbGliL2VudGl0aWVzL1BvaW50TGlnaHRcIik7XG5pbXBvcnQgQWJzdHJhY3RNZXRob2RFcnJvclx0XHRcdD0gcmVxdWlyZShcImF3YXlqcy1jb3JlL2xpYi9lcnJvcnMvQWJzdHJhY3RNZXRob2RFcnJvclwiKTtcbmltcG9ydCBEaXJlY3Rpb25hbFNoYWRvd01hcHBlclx0XHQ9IHJlcXVpcmUoXCJhd2F5anMtY29yZS9saWIvbWF0ZXJpYWxzL3NoYWRvd21hcHBlcnMvRGlyZWN0aW9uYWxTaGFkb3dNYXBwZXJcIik7XG5pbXBvcnQgQ3ViZVRleHR1cmVCYXNlXHRcdFx0XHQ9IHJlcXVpcmUoXCJhd2F5anMtY29yZS9saWIvdGV4dHVyZXMvQ3ViZVRleHR1cmVCYXNlXCIpO1xuaW1wb3J0IFRleHR1cmUyREJhc2VcdFx0XHRcdD0gcmVxdWlyZShcImF3YXlqcy1jb3JlL2xpYi90ZXh0dXJlcy9UZXh0dXJlMkRCYXNlXCIpO1xuXG5pbXBvcnQgUmVuZGVyYWJsZUJhc2VcdFx0XHRcdD0gcmVxdWlyZShcImF3YXlqcy1zdGFnZWdsL2xpYi9jb3JlL3Bvb2wvUmVuZGVyYWJsZUJhc2VcIik7XG5pbXBvcnQgSUNvbnRleHRTdGFnZUdMXHRcdFx0XHQ9IHJlcXVpcmUoXCJhd2F5anMtc3RhZ2VnbC9saWIvY29yZS9zdGFnZWdsL0lDb250ZXh0U3RhZ2VHTFwiKTtcbmltcG9ydCBNZXRob2RWT1x0XHRcdFx0XHRcdD0gcmVxdWlyZShcImF3YXlqcy1zdGFnZWdsL2xpYi9tYXRlcmlhbHMvY29tcGlsYXRpb24vTWV0aG9kVk9cIik7XG5pbXBvcnQgU2hhZGVyTGlnaHRpbmdPYmplY3RcdFx0XHQ9IHJlcXVpcmUoXCJhd2F5anMtc3RhZ2VnbC9saWIvbWF0ZXJpYWxzL2NvbXBpbGF0aW9uL1NoYWRlckxpZ2h0aW5nT2JqZWN0XCIpO1xuaW1wb3J0IFNoYWRlck9iamVjdEJhc2VcdFx0XHRcdD0gcmVxdWlyZShcImF3YXlqcy1zdGFnZWdsL2xpYi9tYXRlcmlhbHMvY29tcGlsYXRpb24vU2hhZGVyT2JqZWN0QmFzZVwiKTtcbmltcG9ydCBTaGFkZXJSZWdpc3RlckNhY2hlXHRcdFx0PSByZXF1aXJlKFwiYXdheWpzLXN0YWdlZ2wvbGliL21hdGVyaWFscy9jb21waWxhdGlvbi9TaGFkZXJSZWdpc3RlckNhY2hlXCIpO1xuaW1wb3J0IFNoYWRlclJlZ2lzdGVyRGF0YVx0XHRcdD0gcmVxdWlyZShcImF3YXlqcy1zdGFnZWdsL2xpYi9tYXRlcmlhbHMvY29tcGlsYXRpb24vU2hhZGVyUmVnaXN0ZXJEYXRhXCIpO1xuaW1wb3J0IFNoYWRlclJlZ2lzdGVyRWxlbWVudFx0XHQ9IHJlcXVpcmUoXCJhd2F5anMtc3RhZ2VnbC9saWIvbWF0ZXJpYWxzL2NvbXBpbGF0aW9uL1NoYWRlclJlZ2lzdGVyRWxlbWVudFwiKTtcbmltcG9ydCBTaGFkb3dNYXBNZXRob2RCYXNlXHRcdFx0PSByZXF1aXJlKFwiYXdheWpzLXN0YWdlZ2wvbGliL21hdGVyaWFscy9tZXRob2RzL1NoYWRvd01hcE1ldGhvZEJhc2VcIik7XG5cbi8qKlxuICogU2hhZG93TWV0aG9kQmFzZSBwcm92aWRlcyBhbiBhYnN0cmFjdCBtZXRob2QgZm9yIHNpbXBsZSAobm9uLXdyYXBwaW5nKSBzaGFkb3cgbWFwIG1ldGhvZHMuXG4gKi9cbmNsYXNzIFNoYWRvd01ldGhvZEJhc2UgZXh0ZW5kcyBTaGFkb3dNYXBNZXRob2RCYXNlXG57XG5cdHB1YmxpYyBfcERlcHRoTWFwQ29vcmRSZWc6U2hhZGVyUmVnaXN0ZXJFbGVtZW50O1xuXHRwdWJsaWMgX3BVc2VQb2ludDpib29sZWFuO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IFNoYWRvd01ldGhvZEJhc2Ugb2JqZWN0LlxuXHQgKiBAcGFyYW0gY2FzdGluZ0xpZ2h0IFRoZSBsaWdodCB1c2VkIHRvIGNhc3Qgc2hhZG93cy5cblx0ICovXG5cdGNvbnN0cnVjdG9yKGNhc3RpbmdMaWdodDpMaWdodEJhc2UpXG5cdHtcblx0XHR0aGlzLl9wVXNlUG9pbnQgPSAoY2FzdGluZ0xpZ2h0IGluc3RhbmNlb2YgUG9pbnRMaWdodCk7XG5cblx0XHRzdXBlcihjYXN0aW5nTGlnaHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRwdWJsaWMgaUluaXRWTyhzaGFkZXJPYmplY3Q6U2hhZGVyTGlnaHRpbmdPYmplY3QsIG1ldGhvZFZPOk1ldGhvZFZPKVxuXHR7XG5cdFx0bWV0aG9kVk8ubmVlZHNWaWV3ID0gdHJ1ZTtcblx0XHRtZXRob2RWTy5uZWVkc0dsb2JhbFZlcnRleFBvcyA9IHRydWU7XG5cdFx0bWV0aG9kVk8ubmVlZHNHbG9iYWxGcmFnbWVudFBvcyA9IHRoaXMuX3BVc2VQb2ludDtcblx0XHRtZXRob2RWTy5uZWVkc05vcm1hbHMgPSBzaGFkZXJPYmplY3QubnVtTGlnaHRzID4gMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0cHVibGljIGlJbml0Q29uc3RhbnRzKHNoYWRlck9iamVjdDpTaGFkZXJPYmplY3RCYXNlLCBtZXRob2RWTzpNZXRob2RWTylcblx0e1xuXHRcdHZhciBmcmFnbWVudERhdGE6QXJyYXk8bnVtYmVyPiA9IHNoYWRlck9iamVjdC5mcmFnbWVudENvbnN0YW50RGF0YTtcblx0XHR2YXIgdmVydGV4RGF0YTpBcnJheTxudW1iZXI+ID0gc2hhZGVyT2JqZWN0LnZlcnRleENvbnN0YW50RGF0YTtcblx0XHR2YXIgaW5kZXg6bnVtYmVyIC8qaW50Ki8gPSBtZXRob2RWTy5mcmFnbWVudENvbnN0YW50c0luZGV4O1xuXHRcdGZyYWdtZW50RGF0YVtpbmRleF0gPSAxLjA7XG5cdFx0ZnJhZ21lbnREYXRhW2luZGV4ICsgMV0gPSAxLzI1NS4wO1xuXHRcdGZyYWdtZW50RGF0YVtpbmRleCArIDJdID0gMS82NTAyNS4wO1xuXHRcdGZyYWdtZW50RGF0YVtpbmRleCArIDNdID0gMS8xNjU4MTM3NS4wO1xuXG5cdFx0ZnJhZ21lbnREYXRhW2luZGV4ICsgNl0gPSAwO1xuXHRcdGZyYWdtZW50RGF0YVtpbmRleCArIDddID0gMTtcblxuXHRcdGlmICh0aGlzLl9wVXNlUG9pbnQpIHtcblx0XHRcdGZyYWdtZW50RGF0YVtpbmRleCArIDhdID0gMDtcblx0XHRcdGZyYWdtZW50RGF0YVtpbmRleCArIDldID0gMDtcblx0XHRcdGZyYWdtZW50RGF0YVtpbmRleCArIDEwXSA9IDA7XG5cdFx0XHRmcmFnbWVudERhdGFbaW5kZXggKyAxMV0gPSAxO1xuXHRcdH1cblxuXHRcdGluZGV4ID0gbWV0aG9kVk8udmVydGV4Q29uc3RhbnRzSW5kZXg7XG5cdFx0aWYgKGluZGV4ICE9IC0xKSB7XG5cdFx0XHR2ZXJ0ZXhEYXRhW2luZGV4XSA9IC41O1xuXHRcdFx0dmVydGV4RGF0YVtpbmRleCArIDFdID0gLjU7XG5cdFx0XHR2ZXJ0ZXhEYXRhW2luZGV4ICsgMl0gPSAwLjA7XG5cdFx0XHR2ZXJ0ZXhEYXRhW2luZGV4ICsgM10gPSAxLjA7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFdyYXBwZXJzIHRoYXQgb3ZlcnJpZGUgdGhlIHZlcnRleCBzaGFkZXIgbmVlZCB0byBzZXQgdGhpcyBleHBsaWNpdGx5XG5cdCAqL1xuXHRwdWJsaWMgZ2V0IF9pRGVwdGhNYXBDb29yZFJlZygpOlNoYWRlclJlZ2lzdGVyRWxlbWVudFxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX3BEZXB0aE1hcENvb3JkUmVnO1xuXHR9XG5cblx0cHVibGljIHNldCBfaURlcHRoTWFwQ29vcmRSZWcodmFsdWU6U2hhZGVyUmVnaXN0ZXJFbGVtZW50KVxuXHR7XG5cdFx0dGhpcy5fcERlcHRoTWFwQ29vcmRSZWcgPSB2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0cHVibGljIGlDbGVhbkNvbXBpbGF0aW9uRGF0YSgpXG5cdHtcblx0XHRzdXBlci5pQ2xlYW5Db21waWxhdGlvbkRhdGEoKTtcblxuXHRcdHRoaXMuX3BEZXB0aE1hcENvb3JkUmVnID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0cHVibGljIGlHZXRWZXJ0ZXhDb2RlKHNoYWRlck9iamVjdDpTaGFkZXJPYmplY3RCYXNlLCBtZXRob2RWTzpNZXRob2RWTywgcmVnQ2FjaGU6U2hhZGVyUmVnaXN0ZXJDYWNoZSwgc2hhcmVkUmVnaXN0ZXJzOlNoYWRlclJlZ2lzdGVyRGF0YSk6c3RyaW5nXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fcFVzZVBvaW50PyB0aGlzLl9wR2V0UG9pbnRWZXJ0ZXhDb2RlKG1ldGhvZFZPLCByZWdDYWNoZSwgc2hhcmVkUmVnaXN0ZXJzKTp0aGlzLnBHZXRQbGFuYXJWZXJ0ZXhDb2RlKG1ldGhvZFZPLCByZWdDYWNoZSwgc2hhcmVkUmVnaXN0ZXJzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSB2ZXJ0ZXggY29kZSBmb3Igc2hhZG93IG1hcHBpbmcgd2l0aCBhIHBvaW50IGxpZ2h0LlxuXHQgKlxuXHQgKiBAcGFyYW0gbWV0aG9kVk8gVGhlIE1ldGhvZFZPIG9iamVjdCBsaW5raW5nIHRoaXMgbWV0aG9kIHdpdGggdGhlIHBhc3MgY3VycmVudGx5IGJlaW5nIGNvbXBpbGVkLlxuXHQgKiBAcGFyYW0gcmVnQ2FjaGUgVGhlIHJlZ2lzdGVyIGNhY2hlIHVzZWQgZHVyaW5nIHRoZSBjb21waWxhdGlvbi5cblx0ICovXG5cdHB1YmxpYyBfcEdldFBvaW50VmVydGV4Q29kZShtZXRob2RWTzpNZXRob2RWTywgcmVnQ2FjaGU6U2hhZGVyUmVnaXN0ZXJDYWNoZSwgc2hhcmVkUmVnaXN0ZXJzOlNoYWRlclJlZ2lzdGVyRGF0YSk6c3RyaW5nXG5cdHtcblx0XHRtZXRob2RWTy52ZXJ0ZXhDb25zdGFudHNJbmRleCA9IC0xO1xuXHRcdHJldHVybiBcIlwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHZlcnRleCBjb2RlIGZvciBzaGFkb3cgbWFwcGluZyB3aXRoIGEgcGxhbmFyIHNoYWRvdyBtYXAgKGZlOiBkaXJlY3Rpb25hbCBsaWdodHMpLlxuXHQgKlxuXHQgKiBAcGFyYW0gbWV0aG9kVk8gVGhlIE1ldGhvZFZPIG9iamVjdCBsaW5raW5nIHRoaXMgbWV0aG9kIHdpdGggdGhlIHBhc3MgY3VycmVudGx5IGJlaW5nIGNvbXBpbGVkLlxuXHQgKiBAcGFyYW0gcmVnQ2FjaGUgVGhlIHJlZ2lzdGVyIGNhY2hlIHVzZWQgZHVyaW5nIHRoZSBjb21waWxhdGlvbi5cblx0ICovXG5cdHB1YmxpYyBwR2V0UGxhbmFyVmVydGV4Q29kZShtZXRob2RWTzpNZXRob2RWTywgcmVnQ2FjaGU6U2hhZGVyUmVnaXN0ZXJDYWNoZSwgc2hhcmVkUmVnaXN0ZXJzOlNoYWRlclJlZ2lzdGVyRGF0YSk6c3RyaW5nXG5cdHtcblx0XHR2YXIgY29kZTpzdHJpbmcgPSBcIlwiO1xuXHRcdHZhciB0ZW1wOlNoYWRlclJlZ2lzdGVyRWxlbWVudCA9IHJlZ0NhY2hlLmdldEZyZWVWZXJ0ZXhWZWN0b3JUZW1wKCk7XG5cdFx0dmFyIGRhdGFSZWc6U2hhZGVyUmVnaXN0ZXJFbGVtZW50ID0gcmVnQ2FjaGUuZ2V0RnJlZVZlcnRleENvbnN0YW50KCk7XG5cdFx0dmFyIGRlcHRoTWFwUHJvajpTaGFkZXJSZWdpc3RlckVsZW1lbnQgPSByZWdDYWNoZS5nZXRGcmVlVmVydGV4Q29uc3RhbnQoKTtcblx0XHRyZWdDYWNoZS5nZXRGcmVlVmVydGV4Q29uc3RhbnQoKTtcblx0XHRyZWdDYWNoZS5nZXRGcmVlVmVydGV4Q29uc3RhbnQoKTtcblx0XHRyZWdDYWNoZS5nZXRGcmVlVmVydGV4Q29uc3RhbnQoKTtcblx0XHR0aGlzLl9wRGVwdGhNYXBDb29yZFJlZyA9IHJlZ0NhY2hlLmdldEZyZWVWYXJ5aW5nKCk7XG5cdFx0bWV0aG9kVk8udmVydGV4Q29uc3RhbnRzSW5kZXggPSBkYXRhUmVnLmluZGV4KjQ7XG5cblx0XHQvLyB0b2RvOiBjYW4gZXBzaWxvbiBiZSBhcHBsaWVkIGhlcmUgaW5zdGVhZCBvZiBmcmFnbWVudCBzaGFkZXI/XG5cblx0XHRjb2RlICs9IFwibTQ0IFwiICsgdGVtcCArIFwiLCBcIiArIHNoYXJlZFJlZ2lzdGVycy5nbG9iYWxQb3NpdGlvblZlcnRleCArIFwiLCBcIiArIGRlcHRoTWFwUHJvaiArIFwiXFxuXCIgKyBcImRpdiBcIiArIHRlbXAgKyBcIiwgXCIgKyB0ZW1wICsgXCIsIFwiICsgdGVtcCArIFwiLndcXG5cIiArIFwibXVsIFwiICsgdGVtcCArIFwiLnh5LCBcIiArIHRlbXAgKyBcIi54eSwgXCIgKyBkYXRhUmVnICsgXCIueHlcXG5cIiArIFwiYWRkIFwiICsgdGhpcy5fcERlcHRoTWFwQ29vcmRSZWcgKyBcIiwgXCIgKyB0ZW1wICsgXCIsIFwiICsgZGF0YVJlZyArIFwiLnh4d3pcXG5cIjtcblx0XHQvL1wic3ViIFwiICsgdGhpcy5fcERlcHRoTWFwQ29vcmRSZWcgKyBcIi56LCBcIiArIHRoaXMuX3BEZXB0aE1hcENvb3JkUmVnICsgXCIueiwgXCIgKyB0aGlzLl9wRGVwdGhNYXBDb29yZFJlZyArIFwiLndcXG5cIjtcblxuXHRcdHJldHVybiBjb2RlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRwdWJsaWMgaUdldEZyYWdtZW50Q29kZShzaGFkZXJPYmplY3Q6U2hhZGVyT2JqZWN0QmFzZSwgbWV0aG9kVk86TWV0aG9kVk8sIHRhcmdldFJlZzpTaGFkZXJSZWdpc3RlckVsZW1lbnQsIHJlZ2lzdGVyQ2FjaGU6U2hhZGVyUmVnaXN0ZXJDYWNoZSwgc2hhcmVkUmVnaXN0ZXJzOlNoYWRlclJlZ2lzdGVyRGF0YSk6c3RyaW5nXG5cdHtcblx0XHR2YXIgY29kZTpzdHJpbmcgPSB0aGlzLl9wVXNlUG9pbnQ/IHRoaXMuX3BHZXRQb2ludEZyYWdtZW50Q29kZShtZXRob2RWTywgdGFyZ2V0UmVnLCByZWdpc3RlckNhY2hlLCBzaGFyZWRSZWdpc3RlcnMpOnRoaXMuX3BHZXRQbGFuYXJGcmFnbWVudENvZGUobWV0aG9kVk8sIHRhcmdldFJlZywgcmVnaXN0ZXJDYWNoZSwgc2hhcmVkUmVnaXN0ZXJzKTtcblx0XHRjb2RlICs9IFwiYWRkIFwiICsgdGFyZ2V0UmVnICsgXCIudywgXCIgKyB0YXJnZXRSZWcgKyBcIi53LCBmY1wiICsgKG1ldGhvZFZPLmZyYWdtZW50Q29uc3RhbnRzSW5kZXgvNCArIDEpICsgXCIueVxcblwiICsgXCJzYXQgXCIgKyB0YXJnZXRSZWcgKyBcIi53LCBcIiArIHRhcmdldFJlZyArIFwiLndcXG5cIjtcblx0XHRyZXR1cm4gY29kZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBmcmFnbWVudCBjb2RlIGZvciBzaGFkb3cgbWFwcGluZyB3aXRoIGEgcGxhbmFyIHNoYWRvdyBtYXAuXG5cdCAqIEBwYXJhbSBtZXRob2RWTyBUaGUgTWV0aG9kVk8gb2JqZWN0IGxpbmtpbmcgdGhpcyBtZXRob2Qgd2l0aCB0aGUgcGFzcyBjdXJyZW50bHkgYmVpbmcgY29tcGlsZWQuXG5cdCAqIEBwYXJhbSByZWdDYWNoZSBUaGUgcmVnaXN0ZXIgY2FjaGUgdXNlZCBkdXJpbmcgdGhlIGNvbXBpbGF0aW9uLlxuXHQgKiBAcGFyYW0gdGFyZ2V0UmVnIFRoZSByZWdpc3RlciB0byBjb250YWluIHRoZSBzaGFkb3cgY292ZXJhZ2Vcblx0ICogQHJldHVyblxuXHQgKi9cblx0cHVibGljIF9wR2V0UGxhbmFyRnJhZ21lbnRDb2RlKG1ldGhvZFZPOk1ldGhvZFZPLCB0YXJnZXRSZWc6U2hhZGVyUmVnaXN0ZXJFbGVtZW50LCByZWdDYWNoZTpTaGFkZXJSZWdpc3RlckNhY2hlLCBzaGFyZWRSZWdpc3RlcnM6U2hhZGVyUmVnaXN0ZXJEYXRhKTpzdHJpbmdcblx0e1xuXHRcdHRocm93IG5ldyBBYnN0cmFjdE1ldGhvZEVycm9yKCk7XG5cdFx0cmV0dXJuIFwiXCI7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgZnJhZ21lbnQgY29kZSBmb3Igc2hhZG93IG1hcHBpbmcgd2l0aCBhIHBvaW50IGxpZ2h0LlxuXHQgKiBAcGFyYW0gbWV0aG9kVk8gVGhlIE1ldGhvZFZPIG9iamVjdCBsaW5raW5nIHRoaXMgbWV0aG9kIHdpdGggdGhlIHBhc3MgY3VycmVudGx5IGJlaW5nIGNvbXBpbGVkLlxuXHQgKiBAcGFyYW0gcmVnQ2FjaGUgVGhlIHJlZ2lzdGVyIGNhY2hlIHVzZWQgZHVyaW5nIHRoZSBjb21waWxhdGlvbi5cblx0ICogQHBhcmFtIHRhcmdldFJlZyBUaGUgcmVnaXN0ZXIgdG8gY29udGFpbiB0aGUgc2hhZG93IGNvdmVyYWdlXG5cdCAqIEByZXR1cm5cblx0ICovXG5cdHB1YmxpYyBfcEdldFBvaW50RnJhZ21lbnRDb2RlKG1ldGhvZFZPOk1ldGhvZFZPLCB0YXJnZXRSZWc6U2hhZGVyUmVnaXN0ZXJFbGVtZW50LCByZWdDYWNoZTpTaGFkZXJSZWdpc3RlckNhY2hlLCBzaGFyZWRSZWdpc3RlcnM6U2hhZGVyUmVnaXN0ZXJEYXRhKTpzdHJpbmdcblx0e1xuXHRcdHRocm93IG5ldyBBYnN0cmFjdE1ldGhvZEVycm9yKCk7XG5cdFx0cmV0dXJuIFwiXCI7XG5cdH1cblxuXHQvKipcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG5cdHB1YmxpYyBpU2V0UmVuZGVyU3RhdGUoc2hhZGVyT2JqZWN0OlNoYWRlck9iamVjdEJhc2UsIG1ldGhvZFZPOk1ldGhvZFZPLCByZW5kZXJhYmxlOlJlbmRlcmFibGVCYXNlLCBzdGFnZTpTdGFnZSwgY2FtZXJhOkNhbWVyYSlcblx0e1xuXHRcdGlmICghdGhpcy5fcFVzZVBvaW50KVxuXHRcdFx0KDxEaXJlY3Rpb25hbFNoYWRvd01hcHBlcj4gdGhpcy5fcFNoYWRvd01hcHBlcikuaURlcHRoUHJvamVjdGlvbi5jb3B5UmF3RGF0YVRvKHNoYWRlck9iamVjdC52ZXJ0ZXhDb25zdGFudERhdGEsIG1ldGhvZFZPLnZlcnRleENvbnN0YW50c0luZGV4ICsgNCwgdHJ1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgZnJhZ21lbnQgY29kZSBmb3IgY29tYmluaW5nIHRoaXMgbWV0aG9kIHdpdGggYSBjYXNjYWRlZCBzaGFkb3cgbWFwIG1ldGhvZC5cblx0ICogQHBhcmFtIG1ldGhvZFZPIFRoZSBNZXRob2RWTyBvYmplY3QgbGlua2luZyB0aGlzIG1ldGhvZCB3aXRoIHRoZSBwYXNzIGN1cnJlbnRseSBiZWluZyBjb21waWxlZC5cblx0ICogQHBhcmFtIHJlZ0NhY2hlIFRoZSByZWdpc3RlciBjYWNoZSB1c2VkIGR1cmluZyB0aGUgY29tcGlsYXRpb24uXG5cdCAqIEBwYXJhbSBkZWNvZGVSZWdpc3RlciBUaGUgcmVnaXN0ZXIgY29udGFpbmluZyB0aGUgZGF0YSB0byBkZWNvZGUgdGhlIHNoYWRvdyBtYXAgZGVwdGggdmFsdWUuXG5cdCAqIEBwYXJhbSBkZXB0aFRleHR1cmUgVGhlIHRleHR1cmUgY29udGFpbmluZyB0aGUgc2hhZG93IG1hcC5cblx0ICogQHBhcmFtIGRlcHRoUHJvamVjdGlvbiBUaGUgcHJvamVjdGlvbiBvZiB0aGUgZnJhZ21lbnQgcmVsYXRpdmUgdG8gdGhlIGxpZ2h0LlxuXHQgKiBAcGFyYW0gdGFyZ2V0UmVnaXN0ZXIgVGhlIHJlZ2lzdGVyIHRvIGNvbnRhaW4gdGhlIHNoYWRvdyBjb3ZlcmFnZVxuXHQgKiBAcmV0dXJuXG5cdCAqL1xuXHRwdWJsaWMgX2lHZXRDYXNjYWRlRnJhZ21lbnRDb2RlKHNoYWRlck9iamVjdDpTaGFkZXJPYmplY3RCYXNlLCBtZXRob2RWTzpNZXRob2RWTywgZGVjb2RlUmVnaXN0ZXI6U2hhZGVyUmVnaXN0ZXJFbGVtZW50LCBkZXB0aFRleHR1cmU6U2hhZGVyUmVnaXN0ZXJFbGVtZW50LCBkZXB0aFByb2plY3Rpb246U2hhZGVyUmVnaXN0ZXJFbGVtZW50LCB0YXJnZXRSZWdpc3RlcjpTaGFkZXJSZWdpc3RlckVsZW1lbnQsIHJlZ2lzdGVyQ2FjaGU6U2hhZGVyUmVnaXN0ZXJDYWNoZSwgc2hhcmVkUmVnaXN0ZXJzOlNoYWRlclJlZ2lzdGVyRGF0YSk6c3RyaW5nXG5cdHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHNoYWRvdyBtZXRob2QgaXMgaW5jb21wYXRpYmxlIHdpdGggY2FzY2FkZSBzaGFkb3dzXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRwdWJsaWMgaUFjdGl2YXRlKHNoYWRlck9iamVjdDpTaGFkZXJPYmplY3RCYXNlLCBtZXRob2RWTzpNZXRob2RWTywgc3RhZ2U6U3RhZ2UpXG5cdHtcblx0XHR2YXIgZnJhZ21lbnREYXRhOkFycmF5PG51bWJlcj4gPSBzaGFkZXJPYmplY3QuZnJhZ21lbnRDb25zdGFudERhdGE7XG5cdFx0dmFyIGluZGV4Om51bWJlciAvKmludCovID0gbWV0aG9kVk8uZnJhZ21lbnRDb25zdGFudHNJbmRleDtcblxuXHRcdGlmICh0aGlzLl9wVXNlUG9pbnQpXG5cdFx0XHRmcmFnbWVudERhdGFbaW5kZXggKyA0XSA9IC1NYXRoLnBvdygxLygoPFBvaW50TGlnaHQ+IHRoaXMuX3BDYXN0aW5nTGlnaHQpLmZhbGxPZmYqdGhpcy5fcEVwc2lsb24pLCAyKTtcblx0XHRlbHNlXG5cdFx0XHRzaGFkZXJPYmplY3QudmVydGV4Q29uc3RhbnREYXRhW21ldGhvZFZPLnZlcnRleENvbnN0YW50c0luZGV4ICsgM10gPSAtMS8oKDxEaXJlY3Rpb25hbFNoYWRvd01hcHBlcj4gdGhpcy5fcFNoYWRvd01hcHBlcikuZGVwdGgqdGhpcy5fcEVwc2lsb24pO1xuXG5cdFx0ZnJhZ21lbnREYXRhW2luZGV4ICsgNV0gPSAxIC0gdGhpcy5fcEFscGhhO1xuXG5cdFx0aWYgKHRoaXMuX3BVc2VQb2ludCkge1xuXHRcdFx0dmFyIHBvczpWZWN0b3IzRCA9IHRoaXMuX3BDYXN0aW5nTGlnaHQuc2NlbmVQb3NpdGlvbjtcblx0XHRcdGZyYWdtZW50RGF0YVtpbmRleCArIDhdID0gcG9zLng7XG5cdFx0XHRmcmFnbWVudERhdGFbaW5kZXggKyA5XSA9IHBvcy55O1xuXHRcdFx0ZnJhZ21lbnREYXRhW2luZGV4ICsgMTBdID0gcG9zLno7XG5cdFx0XHQvLyB1c2VkIHRvIGRlY29tcHJlc3MgZGlzdGFuY2Vcblx0XHRcdHZhciBmOm51bWJlciA9ICg8UG9pbnRMaWdodD4gdGhpcy5fcENhc3RpbmdMaWdodCkuZmFsbE9mZjtcblx0XHRcdGZyYWdtZW50RGF0YVtpbmRleCArIDExXSA9IDEvKDIqZipmKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX3BVc2VQb2ludClcblx0XHRcdCg8SUNvbnRleHRTdGFnZUdMPiBzdGFnZS5jb250ZXh0KS5hY3RpdmF0ZVJlbmRlclRleHR1cmUobWV0aG9kVk8udGV4dHVyZXNJbmRleCwgPFRleHR1cmUyREJhc2U+IHRoaXMuX3BDYXN0aW5nTGlnaHQuc2hhZG93TWFwcGVyLmRlcHRoTWFwKTtcblx0XHQvL2Vsc2Vcblx0XHQvL1x0KDxJQ29udGV4dFN0YWdlR0w+IHN0YWdlLmNvbnRleHQpLmFjdGl2YXRlQ3ViZVJlbmRlclRleHR1cmUobWV0aG9kVk8udGV4dHVyZXNJbmRleCwgPEN1YmVUZXh0dXJlQmFzZT4gdGhpcy5fcENhc3RpbmdMaWdodC5zaGFkb3dNYXBwZXIuZGVwdGhNYXApO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIG1ldGhvZCBzdGF0ZSBmb3IgY2FzY2FkZSBzaGFkb3cgbWFwcGluZy5cblx0ICovXG5cdHB1YmxpYyBpQWN0aXZhdGVGb3JDYXNjYWRlKHNoYWRlck9iamVjdDpTaGFkZXJPYmplY3RCYXNlLCBtZXRob2RWTzpNZXRob2RWTywgc3RhZ2U6U3RhZ2UpXG5cdHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHNoYWRvdyBtZXRob2QgaXMgaW5jb21wYXRpYmxlIHdpdGggY2FzY2FkZSBzaGFkb3dzXCIpO1xuXHR9XG59XG5cbmV4cG9ydCA9IFNoYWRvd01ldGhvZEJhc2U7Il19